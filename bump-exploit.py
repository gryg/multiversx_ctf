import subprocess
import time
import logging
import sys
import asyncio
import random
from pathlib import Path
from concurrent.futures import ThreadPoolExecutor
from datetime import datetime, timedelta

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)

class BumpAutomation:
    def __init__(self, pem_path: str, num_workers: int = 20, base_delay: float = 0.1):
        self.pem_path = Path(pem_path).resolve()
        self.contract = "erd1qqqqqqqqqqqqqpgqnqw2aep56p5hg5ksualpfwav55pvaafjd8ssg4pur0"
        self.logger = logging.getLogger(__name__)
        
        # Performance settings
        self.num_workers = num_workers
        self.base_delay = base_delay
        self.executor = ThreadPoolExecutor(max_workers=num_workers)
        
        # Statistics tracking
        self.successful_bumps = 0
        self.failed_bumps = 0
        self.start_time = None
        
        self._verify_setup()

    def _verify_setup(self):
        if not self.pem_path.exists():
            raise FileNotFoundError(f"PEM file not found at {self.pem_path}")
            
        try:
            result = subprocess.run(["mxpy", "--version"], capture_output=True, text=True)
            if result.returncode == 0:
                self.logger.info(f"Using mxpy version: {result.stdout.strip()}")
                self.logger.info(f"Starting with {self.num_workers} workers and {self.base_delay}s base delay")
            else:
                self.logger.error(f"mxpy check failed: {result.stderr}")
        except Exception as e:
            self.logger.error(f"Error checking mxpy: {str(e)}")

    async def send_bump(self, worker_id: int) -> str:
        """Sends a bump transaction using mxpy"""
        try:
            cmd = [
                "mxpy", "contract", "call",
                self.contract,
                "--proxy", "https://devnet-gateway.multiversx.com",
                "--chain", "D",
                "--pem", str(self.pem_path),
                "--gas-limit", "5000000",
                "--function", "bump",
                "--recall-nonce",
                "--send"
            ]
            
            # Execute command in thread pool to prevent blocking
            loop = asyncio.get_event_loop()
            result = await loop.run_in_executor(
                self.executor,
                lambda: subprocess.run(cmd, capture_output=True, text=True)
            )
            
            if result.returncode != 0:
                raise Exception(f"Command failed with return code {result.returncode}")
                
            tx_hash = None
            for line in result.stdout.split('\n'):
                if 'hash' in line.lower():
                    tx_hash = line.split(':')[-1].strip()
                    break
                    
            if not tx_hash:
                raise ValueError("Could not find transaction hash in output")
                
            self.successful_bumps += 1
            
            # Calculate and log performance metrics
            if self.start_time:
                elapsed = (datetime.now() - self.start_time).total_seconds()
                rate = self.successful_bumps / elapsed
                self.logger.info(f"Worker {worker_id:2d} | Bump #{self.successful_bumps:4d} | Rate: {rate:.2f} tx/s | Hash: {tx_hash}")
            
            return tx_hash
            
        except Exception as e:
            self.failed_bumps += 1
            self.logger.error(f"Worker {worker_id} error: {str(e)}")
            raise

    async def worker(self, worker_id: int):
        """Individual worker that continuously sends bump transactions"""
        while True:
            try:
                await self.send_bump(worker_id)
                
                # Randomized delay to prevent synchronization
                delay = self.base_delay * (0.8 + 0.4 * random.random())
                await asyncio.sleep(delay)
                
            except Exception as e:
                # Longer delay on error
                await asyncio.sleep(self.base_delay * 2)
                continue

    def log_statistics(self):
        """Log current performance statistics"""
        if self.start_time:
            elapsed = (datetime.now() - self.start_time).total_seconds()
            success_rate = self.successful_bumps / elapsed
            total_tx = self.successful_bumps + self.failed_bumps
            success_percent = (self.successful_bumps / total_tx * 100) if total_tx > 0 else 0
            
            self.logger.info(
                f"\nPerformance Statistics:\n"
                f"Successful Bumps: {self.successful_bumps}\n"
                f"Failed Bumps: {self.failed_bumps}\n"
                f"Success Rate: {success_rate:.2f} tx/s\n"
                f"Success Percentage: {success_percent:.1f}%\n"
                f"Total Runtime: {elapsed:.1f}s"
            )

    async def start_bumping_async(self):
        """Start multiple workers to send bump transactions in parallel"""
        self.start_time = datetime.now()
        self.logger.info(f"Starting massive bump automation with {self.num_workers} workers")
        self.logger.info(f"Using PEM file: {self.pem_path}")
        
        try:
            # Create and start all workers
            tasks = [
                asyncio.create_task(self.worker(i))
                for i in range(self.num_workers)
            ]
            
            # Add statistics logging task
            stats_task = asyncio.create_task(self._log_stats_periodically())
            
            # Run everything concurrently
            await asyncio.gather(*tasks, stats_task)
            
        except Exception as e:
            self.logger.error(f"Error in main loop: {str(e)}")
        finally:
            self.log_statistics()

    async def _log_stats_periodically(self):
        """Periodically log statistics"""
        while True:
            await asyncio.sleep(10)  # Log every 10 seconds
            self.log_statistics()

    def start_bumping(self):
        """Main entry point to start the bumping process"""
        try:
            asyncio.run(self.start_bumping_async())
        except KeyboardInterrupt:
            self.logger.info("\nStopping bump automation...")
            self.log_statistics()
        finally:
            self.executor.shutdown(wait=False)

def main():
    # Allow configuration via command line
    pem_path = sys.argv[1] if len(sys.argv) > 1 else "wallet.pem"
    num_workers = int(sys.argv[2]) if len(sys.argv) > 2 else 20
    base_delay = float(sys.argv[3]) if len(sys.argv) > 3 else 0.1
    
    try:
        automation = BumpAutomation(pem_path, num_workers, base_delay)
        automation.start_bumping()
    except KeyboardInterrupt:
        logging.info("\nStopping bump automation...")
    except Exception as e:
        logging.error(f"Failed to start automation: {str(e)}")
        sys.exit(1)

if __name__ == "__main__":
    main()